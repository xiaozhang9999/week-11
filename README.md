# week-11
## 希尔排序
近乎有序的数组更容易排序。基本思想：让数组越来越有序。
将间隔为n/2的元素分为n/2组，分别进行插入排序；
将间隔为n/4的元素分为n/4组，分别进行插入排序；
...
将间隔为1的元素分为1组，分别进行插入排序。
设start=0，到<h,对data[start,start+h,start+2h,..]进行插入排序。
```c++
template <typename T>
void ShellSort(T data[], int length)
{
	int h = length / 2;
	while (h >= 1) {
		for (int start = 0; start < h; start++) {
			//对data[start,start+h,start+2h...]进行插入排序
			for (int i = start+h; i < length; i += h) {
				T t = data[i];
				int j;
				for (j = i; j - h >= 0 && data[j-h] > t; j -= h)
					data[j] = data[j-h];
				data[j ] = t;
			}
		}
		h  /= 2;
	}
}
```
### 性能
希尔排序在理论上比归并排序慢一些，但数据规模相对较小时希尔排序更快一些，规模逐渐变得足够大时时间复杂度为$O(nlogn)$的排序才会逐渐显现出优势。希尔排序比$O(n^2)$的插入，选择，冒泡排序快一些。
因为每次排序都是近乎有序的数组，所以实测希尔排序的性能比理论上好很多。
### 简化
不用分组进行插入排序，直接按顺序对每个元素进行处理即可。
```c++
//代码简化
template <typename T>
void ShellSort1(T data[], int length)
{
	int h = length / 2;
	while (h >= 1) {
		
			//对d[h...n)进行插入排序
			for (int i =  h; i < length; i ++) {
				T t = data[i];
				int j;
				for (j = i; j - h >= 0 && data[j - h] > t; j -= h)
					data[j] = data[j - h];
				data[j] = t;
			}
		h /= 2;
	}
}
```
### 步长序列
不同的步长序列，复杂度分析不同，性能也会有差异。
h:(1，2，4，8，...)
h:(1，4，13，...)此步长序列相比上一个性能更优一些。
## 基于比较的排序算法总结
| 排序算法 |时间复杂度|空间复杂度|特殊元素|稳定性
|--|--|--|--|--|
|选择排序|$O(n^2)$|O(1)||不稳定|
|插入排序|$O(n^2)$|O(1)|完全有序时为O(n)|稳定|
|冒泡排序|$O(n^2)$|O(1)|优化后完全有序时为O(n)|稳定|
|归并排序|$O(nlogn)$|O(n)|优化后完全有序时为O(n)|稳定|
|快速排序|$O(nlogn)$|O(1)|相同元素三路快排为O(n)|不稳定|
|堆排序|$O(nlogn)$|O(1)(优化后）||不稳定|
|希尔排序|$O(nlogn)$~$O(n^2)$|O(1)||不稳定|

**稳定性**排序前相等的两元素，排序后相对位置不变。如果元素只有大小，只有一个域没有其他属性，稳定性没有意义。
## 线段树（区间树）
关心线段（区间）的一类问题。
经典线段树问题：区间染色
对某区间进行染色，m次操作后，可以在[i,j]区间内看见多少种颜色。使用数组实现时，染色操作（更新区间）O(n),查询操作（查询区间）O(n).
另一类经典问题：区间查询，实质：基于区间的统计查询。在一规定区间内数组时动态变化的，对于更新和查询，数组实现为O(n)，使用线段树是O(logn)。
线段树不一定是满二叉树，完全二叉树，一定是平衡二叉树。假设区间有n个元素，若$n=2^k$，需要2n空间的数组来存储，若$n=2^k+1$（最坏情况），需要4n空间的数组来存储。

## Trie 字典树，前缀树
多叉树，通常只用来处理字符串。
字典中有n个条目，使用树查询$O(nlogn)$；使用Trie查询时间复杂度与n无关，只与单个条目字符数有关。
对于Trie每个节点下面有~~26~~若干个指向下一节点的指针（不同语言/情景指针个数可以改变）。
